1. Open `specs/$1/tasks.md` and select the first unchecked actionable task in the todo list to work on. An actionable task is the most granular, concrete item that has no further sub-tasks beneath it (a true leaf node with no children). Always traverse down through all nested levels to find the deepest unchecked item that represents actual work to be done, not a category or grouping. Parent node items should only be marked as complete when all of the descendant node items are marked complete.
2. Using ToDoWrite create a list that includes the following steps:
    - A step to determine the most domain-relevant agent for completing the item. Read the corresponding prompt given in the file named for the item in `specs/$1/task-prompts/`. If no prompt exists for the specific task, first look for a parent task prompt that might provide context, then create an appropriate prompt in the format used by the other prompts, and add it in a markdown file, appropriately named in `specs/$1/task-prompts/`. Prioritize technical implementation and domain expert agents (such as rust-specialist, debug-specialist, performance-engineer) for code changes, architectural agents (such as systems-architect) for design decisions, security concerns to security-engineer, and testing to test-specialist. Also keep in mind project scope, goals, and end use-case. The agent should use the zen precommit tool prior completing their task if it involved code changes.
    - An initial step to task the agent with determining if the prompt, which you will include, is sufficient for the task with the following additions:
      - Ask the agent to walk through their thought process step-by-step in their response.
      - Ask the agent to request any information it feels it needs to do the job properly in their response.
    - A step to iteratively refine the prompt by repeatedly asking the agent to evaluate prompt sufficiency and request needed information, modifying the prompt based on agent feedback and search-specialist discoveries, and continuing until the agent confirms the prompt is sufficient for the task (maximum 3 iterations to prevent infinite loops).
    - A step to update the finalized prompt in the file in `specs/$1/task-prompts/` as needed.
    - A step to task the agent with completing the actual todo item using the prompt from the previous steps. While implementing, keep in mind project scope, goal, and end-use case.
    - A step for committing the change. Use get-agent-hash to get the hash for any agents involved. Any type checking, linting, formatting, and testing quality gates should happen here.
    - A step for tasking test-specialist to review any testing changes for the task. Add tasks to specs/$1/tasks.md for any issues raised, if one doesn't already exist. When deciding to add a task keep in mind the project scope, goals, and end-use case.
    - A step for tasking clean-code-analyst to review any code changes. Add tasks to specs/$1/tasks.md for any issues raised, if one doesn't already exist. When deciding to add a task keep in mind the project scope, goals, and end-use case.
    - A step for tasking solid-principles-assessor to review any code changes. Add tasks to specs/$1/tasks.md for any issues raised, if one doesn't already exist. When deciding to add a task keep in mind the project scope, goals, and end-use case.
    - A step for architectural-patterns-expert to review any code changes. Add tasks to specs/$1/tasks.md for any issues raised, if one doesn't already exist. When deciding to add a task keep in mind the project scope, goals, and end-use case.
    - A step for maintainability-assessor to review any code changes. Add tasks to specs/$1/tasks.md for any issues raised, if one doesn't already exist. When deciding to add a task keep in mind the project scope, goals, and end-use case.
    - A step for api-design-expert to review any code changes. Add tasks to specs/$1/tasks.md for any issues raised, if one doesn't already exist. When deciding to add a task keep in mind the project scope, goals, and end-use case.
    - A step for security-engineer to review any code changes. Add tasks to specs/$1/tasks.md for any issues raised, if one doesn't already exist. When deciding to add a task keep in mind the project scope, goals, and end-use case.
    - A step for documentation-assessor to review any documentation changes. Add tasks to specs/$1/tasks.md for any issues raised, if one doesn't already exist. When deciding to add a task keep in mind the project scope, goals, and end-use case.
    - A step for tasking code-reviewer with doing quality gates for the change using the zen codereview tool. Add tasks to specs/$1/tasks.md for any issues raised, if one doesn't already exist. When deciding to add a task keep in mind the project scope, goals, and end-use case.
3. Carry out the steps in the ToDoWrite list.
4. Assess whether any tasks added to specs/$1/tasks.md are outside of the scope, goals, and end use-case of the project. Refer to specs/$1/plan.md for guidance on the project.
5. Check off the item in `specs/$1/tasks.md` when it is completed. Items with children, should only be marked complete when all items nested below them are marked complete.
